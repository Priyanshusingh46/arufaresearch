export interface Descriptors {
    title?: string;
    description?: string;
}
export declare type SimpleNodeType = 'none' | 'boolean' | 'string' | 'integer';
export declare type CompositeNodeType = 'enum' | 'struct' | 'optional' | 'array' | 'vec' | 'tuple';
export declare type NodeType = SimpleNodeType | CompositeNodeType;
export declare type ParseSchema = None.Schema | Boolean.Schema | Integer.Schema | Str.Schema | Enum.Schema | Optional.Schema | Struct.Schema | Array.Schema | Tuple.Schema | Vec.Schema;
export declare type ParseNode = None.Node | Boolean.Node | Integer.Node | Str.Node | Enum.Node<Struct.Node<{
    [m: string]: ParseNode;
}>[]> | Optional.Node<ParseNode> | Struct.Node<{
    [m: string]: ParseNode;
}> | Array.Node<ParseNode> | Tuple.Node<ParseNode[]> | Vec.Node<ParseNode>;
export declare type SchemaDef<T> = {
    title?: string;
    description?: string;
    ref?: string;
} & T;
export declare type NodeValue<T> = {
    title?: string;
    description?: string;
} & T;
export declare type NodeDef<T extends NodeType, V = {}> = {
    type: T;
    value: NodeValue<V>;
    ref?: string;
};
export declare namespace None {
    type Schema = SchemaDef<{
        type: 'null';
    }>;
    type Node = NodeDef<'none'>;
}
export declare namespace Str {
    type Schema = SchemaDef<{
        type: 'string';
    }>;
    type Node = NodeDef<'string'>;
}
export declare namespace Integer {
    type Schema = SchemaDef<{
        type: 'integer';
        format?: string;
    }>;
    type Node = NodeDef<'integer', {
        size: string;
    }>;
}
export declare namespace Boolean {
    type Schema = SchemaDef<{
        type: 'boolean';
    }>;
    type Node = NodeDef<'boolean'>;
}
export declare namespace Enum {
    type Schema = SchemaDef<{
        anyOf: ParseSchema[];
    }>;
    interface Node<T extends Struct.Node<{
        [m: string]: ParseNode;
    }>[]> {
        type: 'enum';
        value: NodeValue<{
            variants: T;
        }>;
        ref?: string;
    }
}
export declare namespace Optional {
    type Schema = SchemaDef<{
        type: any[];
    }>;
    interface Node<T extends ParseNode> {
        type: 'optional';
        value: NodeValue<{
            body: T;
        }>;
        ref?: string;
    }
}
export declare namespace Struct {
    type Schema = SchemaDef<{
        type: 'object';
        properties: {
            [memberName: string]: ParseSchema;
        };
    }>;
    interface Node<T extends Record<string, ParseNode>> {
        type: 'struct';
        value: NodeValue<{
            members: T;
        }>;
        ref?: string;
    }
}
export declare namespace Array {
    type Schema = SchemaDef<{
        type: 'array';
        items: ParseSchema;
        minItems: number;
        maxItems: number;
    }>;
    interface Node<T extends ParseNode> {
        type: 'array';
        value: NodeValue<{
            contents: T;
            size: number;
        }>;
        ref?: string;
    }
}
export declare namespace Tuple {
    type Schema = SchemaDef<{
        type: 'array';
        items: ParseSchema[];
        minItems: undefined;
        maxItems: undefined;
    }>;
    interface Node<T extends Array<ParseNode>> {
        type: 'tuple';
        value: NodeValue<{
            contents: T;
        }>;
        ref?: string;
    }
}
export declare namespace Vec {
    type Schema = SchemaDef<{
        type: 'array';
        items: ParseSchema;
        minItems: undefined;
        maxItems: undefined;
    }>;
    interface Node<T extends ParseNode> {
        type: 'vec';
        value: NodeValue<{
            contents: T;
        }>;
        ref?: string;
    }
}
export declare type RustStructNode = Struct.Node<{
    [m: string]: Struct.Node<{
        [m: string]: ParseNode;
    }>;
}>;
