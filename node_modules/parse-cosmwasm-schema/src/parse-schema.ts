import _ from 'lodash';
import { ParseNode, ParseSchema, Struct } from './node-types';
export * from './node-types';
import $RefParser from '@apidevtools/json-schema-ref-parser';

const reformatDefinitions = (definitions: {
  [d: string]: { [d: string]: any };
}): any => {
  if (definitions === undefined) {
    return undefined;
  }

  const newDefinitions = _.mapValues(definitions, (v, k) => ({
    ...v,
    ref: k,
  }));

  return newDefinitions;
};

export const parseSchema = async (schema: any): Promise<ParseNode> => {
  const tree = _parse(
    (await $RefParser.dereference({
      ...schema,
      definitions: reformatDefinitions(schema.definitions),
    })) as any
  );
  return tree;
};

export default parseSchema;

export const _parse = (schema: ParseSchema): ParseNode => {
  const { title, description, ref } = schema;

  if ('allOf' in schema) {
    return _parse(schema['allOf'][0]);
  }

  if ('anyOf' in schema) {
    let variants: ParseNode[] = [];
    schema.anyOf.forEach(v => {
      variants.push(_parse(v));
    });

    if (
      variants.length == 2 &&
      variants.findIndex(v => v.type === 'none') !== -1
    ) {
      return {
        ref,
        type: 'optional',
        value: {
          title,
          description,
          body: variants[0],
        },
      };
    }

    return {
      ref,
      type: 'enum',
      value: {
        title,
        description,
        variants: variants as Struct.Node<{ [m: string]: ParseNode }>[],
      },
    };
  }

  if (schema.type === 'null') {
    return {
      ref,
      type: 'none',
      value: {
        title,
        description,
      },
    };
  }

  if (schema.type === 'string') {
    return {
      ref,
      type: 'string',
      value: {
        title,
        description,
      },
    };
  }

  if (schema.type === 'boolean') {
    return {
      ref,
      type: 'boolean',
      value: {
        title,
        description,
      },
    };
  }

  if (schema.type === 'integer') {
    return {
      ref,
      type: 'integer',
      value: {
        title,
        description,
        size: schema.format === 'uint64' ? 'u64' : 'u32',
      },
    };
  }

  if (schema.type === 'object') {
    let members: Struct.Node<any>['value']['members'] = {};
    Object.entries(schema.properties || {}).forEach(
      ([member_name, member_schema]) => {
        members[member_name] = _parse(member_schema);
      }
    );
    return {
      ref,
      type: 'struct',
      value: {
        title,
        description,
        members,
      },
    };
  }

  if (schema.type === 'array') {
    if (Array.isArray(schema.items)) {
      let contents = schema.items.map(x => _parse(x));
      return {
        ref,
        type: 'tuple',
        value: {
          title,
          description,
          contents,
        },
      };
    } else {
      if (
        schema.maxItems !== undefined &&
        schema.minItems !== undefined &&
        schema.maxItems === schema.minItems
      ) {
        return {
          ref,
          type: 'array',
          value: {
            title,
            description,
            contents: _parse(schema.items),
            size: schema.maxItems,
          },
        };
      }
      return {
        ref,
        type: 'vec',
        value: {
          title,
          description,
          contents: _parse(schema.items),
        },
      };
    }
  }

  if (Array.isArray(schema.type)) {
    if (schema.type.includes('null')) {
      let new_schema: any = {
        ...schema,
        type: schema.type[0],
      };
      return {
        ref,
        type: 'optional',
        value: {
          title,
          description,
          body: _parse(new_schema),
        },
      };
    }
  }

  throw new Error(`could not parse schema: ${JSON.stringify(schema, null, 2)}`);
};
