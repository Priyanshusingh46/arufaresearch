"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialize = void 0;
const chalk_1 = __importDefault(require("chalk"));
const enquirer_1 = __importDefault(require("enquirer"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const fetch_1 = require("../util/fetch");
const project_creation_1 = require("./project-creation");
const TEMPLATES_GIT_REMOTE = 'arufa-research/polar-templates';
const DEFAULT_TEMPLATE = 'counter';
function isYarnProject(destination) {
    return fs_extra_1.default.existsSync(path_1.default.join(destination, "yarn.lock"));
}
/**
 * Confirm if user wants to install project dependencies in template directory
 * @param name Selected Dapp template name
 * @param destination location to initialize template
 */
async function confirmDepInstallation(name, destination) {
    const { default: enquirer } = await Promise.resolve().then(() => __importStar(require("enquirer")));
    let responses;
    const packageManager = isYarnProject(destination) ? "yarn" : "npm";
    try {
        responses = await enquirer.prompt([
            (0, project_creation_1.createConfirmationPrompt)("shouldInstall", `Do you want to install template ${name}'s dependencies with ${packageManager} ?`)
        ]);
    }
    catch (e) {
        if (e === "") {
            return false;
        }
        throw e;
    }
    return responses.shouldInstall;
}
/**
 * Checks if the destination directory is non-empty and confirm if the user
 * wants to proceed with the initializing, skips if --force is used.
 * @param destination location to initialize template
 * @param force true if --force flag is used
 */
async function checkDir(destination, force) {
    if (!force) {
        const initDir = fs_extra_1.default.readdirSync(destination);
        let responses;
        if (initDir.length) {
            console.log(`This directory is non-empty...`);
            try {
                responses = await enquirer_1.default.prompt([
                    (0, project_creation_1.createConfirmationPrompt)("shouldProceedWithNonEmptyDir", `Do you want to proceed with the initialization?`)
                ]);
            }
            catch (e) {
                if (e === "") {
                    return;
                }
                throw e;
            }
            if (!responses.shouldProceedWithNonEmptyDir) {
                console.log("Initialization cancelled");
                process.exit();
            }
        }
    }
}
/**
 * Ensures that the template passed by user exists in arufa-research/polar-templates,
 * otherwise user can select a template from the existing templates or exit initialization
 * @param basePath path to temporary directory (contains all templates)
 * @param templateName template name passed by user (bare if no template name is passed)
 */
async function checkTemplateExists(basePath, templateName) {
    const templatePath = path_1.default.join(basePath, templateName);
    if (fs_extra_1.default.existsSync(templatePath)) {
        return [templatePath, templateName];
    }
    else {
        console.log(chalk_1.default.red(`Error occurred: template "${templateName}" does not exist in ${TEMPLATES_GIT_REMOTE}`));
        const prompt = new enquirer_1.default.Select({
            name: 'Select an option',
            message: 'Do you want to pick an existing template or exit?',
            choices: ['Pick an existing template', 'exit']
        });
        const response = await prompt.run();
        if (response === 'exit') {
            console.log("Initialization cancelled");
            process.exit();
        }
        else {
            const dApps = fs_extra_1.default.readdirSync(basePath, { withFileTypes: true })
                .filter(dirent => dirent.isDirectory())
                .map(dirent => dirent.name);
            const dappsPrompt = new enquirer_1.default.Select({
                name: 'dapps',
                message: 'Pick a template',
                choices: dApps
            });
            const selectedDapp = await dappsPrompt.run();
            return [path_1.default.join(basePath, selectedDapp), selectedDapp];
        }
    }
}
/**
 * returns complete path (eg. "./" => current working directory)
 * @param destination base path
 */
function _normalizeDestination(destination) {
    const workingDirectory = process.cwd();
    if (!destination) {
        return workingDirectory;
    }
    if (path_1.default.isAbsolute(destination))
        return destination;
    return path_1.default.join(workingDirectory, destination);
}
/**
 * Initialize a template from 'arufa-research/polar-templates' with given name
 * and destination
 * @param force --force flag. If true then contents in destination directory are overwritten
 * @param templateName templateName to initialize from arufa-research/polar-templates.
 * @param destination destination directory to initialize template to.
 * Defaults to current working directory
 *  - If template name is not passed, the default template is initialized.
 *  - If template name passed is incorrect (template does not exist),
 *    then user is asked to initialize
 *    from one of the existing templates or exit initializing
 *  - If there are conflicting files while copying template,
 *    then user is asked to overwrite each file
 *     or not (if --force is not used).
 *  - If `--force` is used, then conflicting files are overwritten.
 */
async function initialize({ force, projectName, templateName, destination }) {
    await (0, project_creation_1.printWelcomeMessage)();
    const normalizedDestination = _normalizeDestination(destination);
    fs_extra_1.default.ensureDirSync(normalizedDestination);
    await checkDir(normalizedDestination, force);
    const tempDir = await (0, fetch_1.setUpTempDirectory)();
    const tempDirPath = tempDir.path;
    const tempDirCleanup = tempDir.cleanupCallback;
    console.info(`* Fetching templates from ${TEMPLATES_GIT_REMOTE} *`);
    await (0, fetch_1.fetchRepository)(TEMPLATES_GIT_REMOTE, tempDirPath);
    if (templateName === undefined) {
        console.log(`Template name not passed: using default template ${chalk_1.default.green(DEFAULT_TEMPLATE)}`);
        templateName = DEFAULT_TEMPLATE;
    }
    let templatePath;
    [templatePath, templateName] = await checkTemplateExists(tempDirPath, templateName);
    await (0, fetch_1.copyTemplatetoDestination)(templatePath, normalizedDestination, force);
    tempDirCleanup(); // clean temporary directory
    console.log(chalk_1.default.greenBright(`\n★ Template ${templateName} initialized in ${normalizedDestination} ★\n`));
    // install dependencies in /templatePath
    const shouldInstallDependencies = await confirmDepInstallation(templateName, normalizedDestination);
    const packageManager = isYarnProject(normalizedDestination) ? "yarn" : "npm";
    let shouldShowInstallationInstructions;
    if (shouldInstallDependencies) {
        const installed = await (0, project_creation_1.installDependencies)(packageManager, ['install'], normalizedDestination);
        if (!installed) {
            console.warn(chalk_1.default.red("Failed to install the sample project's dependencies"));
        }
        shouldShowInstallationInstructions = !installed;
    }
    else {
        shouldShowInstallationInstructions = true;
    }
    if (shouldShowInstallationInstructions) {
        console.log(chalk_1.default.yellow(`\nInstall your project dependencies using '${packageManager} install'`));
    }
    (0, project_creation_1.printSuggestedCommands)(projectName);
}
exports.initialize = initialize;
