"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertPolarInvariant = exports.applyErrorMessageTemplate = exports.PolarPluginError = exports.PolarError = void 0;
const caller_package_1 = require("../util/caller-package");
const strings_1 = require("../util/strings");
const errors_list_1 = require("./errors-list");
class PolarError extends Error {
    constructor(errorDescriptor, messageArguments = {}, // eslint-disable-line  @typescript-eslint/no-explicit-any
    parentError) {
        const prefix = `${(0, errors_list_1.getErrorCode)(errorDescriptor)}: `;
        const formattedMessage = applyErrorMessageTemplate(errorDescriptor.message, messageArguments);
        super(prefix + formattedMessage);
        this.errorDescriptor = errorDescriptor;
        this.number = errorDescriptor.number;
        this.messageArguments = messageArguments;
        if (parentError instanceof Error) {
            this.parent = parentError;
        }
        this._isPolarError = true;
        Object.setPrototypeOf(this, PolarError.prototype);
    }
    static isPolarError(other) {
        return (other !== undefined && other !== null && other._isPolarError === true);
    }
    static isPolarErrorType(other, // eslint-disable-line  
    descriptor) {
        return (PolarError.isPolarError(other) &&
            other.errorDescriptor.number === descriptor.number);
    }
}
exports.PolarError = PolarError;
/**
 * This class is used to throw errors from polar plugins made by third parties.
 */
class PolarPluginError extends Error {
    constructor(pluginNameOrMessage, messageOrParent, parent) {
        if (typeof messageOrParent === 'string') {
            super(messageOrParent);
            this.pluginName = pluginNameOrMessage;
            this.parent = parent;
        }
        else {
            super(pluginNameOrMessage);
            // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion
            this.pluginName = (0, caller_package_1.getClosestCallerPackage)();
            this.parent = messageOrParent;
        }
        this._isPolarPluginError = true;
        Object.setPrototypeOf(this, PolarPluginError.prototype);
    }
    static isPolarPluginError(other) {
        return (other !== undefined &&
            other !== null &&
            other._isPolarPluginError === true);
    }
}
exports.PolarPluginError = PolarPluginError;
/**
 * This function applies error messages templates like this:
 *
 *  - Template is a string which contains a variable tags. A variable tag is a
 *    a variable name surrounded by %. Eg: %plugin1%
 *  - A variable name is a string of alphanumeric ascii characters.
 *  - Every variable tag is replaced by its value.
 *  - %% is replaced by %.
 *  - Values can't contain variable tags.
 *  - If a variable is not present in the template, but present in the values
 *    object, an error is thrown.
 *
 * @param template The template string.
 * @param values A map of variable names to their values.
 */
function applyErrorMessageTemplate(template, 
// eslint-disable-next-line
values) {
    return _applyErrorMessageTemplate(template, values);
}
exports.applyErrorMessageTemplate = applyErrorMessageTemplate;
/* eslint-disable sonarjs/cognitive-complexity */
function _applyErrorMessageTemplate(template, 
// eslint-disable-next-line
values) {
    if (template.includes('%%')) {
        return template
            .split('%%')
            .map((part) => _applyErrorMessageTemplate(part, values))
            .join('%');
    }
    for (const variableName of Object.keys(values)) {
        let value;
        if (values[variableName] === undefined) {
            value = 'undefined';
        }
        else if (values[variableName] === null) {
            value = 'null';
        }
        else {
            value = values[variableName].toString();
        }
        if (value === undefined) {
            value = 'undefined';
        }
        const variableTag = `%${variableName}%`;
        template = (0, strings_1.replaceAll)(template, variableTag, value);
    }
    return template;
}
function assertPolarInvariant(invariant, message) {
    if (!invariant) {
        throw new PolarError(errors_list_1.ERRORS.GENERAL.ASSERTION_ERROR, { message });
    }
}
exports.assertPolarInvariant = assertPolarInvariant;
