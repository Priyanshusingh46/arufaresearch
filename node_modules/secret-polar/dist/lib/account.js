"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountByName = exports.UserAccountI = void 0;
const context_1 = require("../internal/context");
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
const client_1 = require("./client");
class UserAccountI {
    constructor(account) {
        this.account = account;
    }
    async setupClient(env) {
        this.client = await (0, client_1.getClient)(env.network);
    }
    async getAccountInfo() {
        if (this.client === undefined) {
            throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.CLIENT_NOT_LOADED);
        }
        return await this.client.query.auth.account({ address: this.account.address });
    }
    async getBalance() {
        if (this.client === undefined) {
            throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.CLIENT_NOT_LOADED);
        }
        const info = await this.client.query.bank.balance({
            address: this.account.address,
            denom: "uscrt"
        });
        if (info === undefined) {
            throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.BALANCE_UNDEFINED);
        }
        return [info.balance ?? { amount: "0", denom: "uscrt" }];
    }
}
exports.UserAccountI = UserAccountI;
async function getAccountByName(name) {
    const env = context_1.PolarContext.getPolarContext().getRuntimeEnv();
    if (env.network.config.accounts === undefined) {
        throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.ACCOUNT_DOES_NOT_EXIST, { name: name });
    }
    for (const value of env.network.config.accounts) {
        if (value.name === name) {
            const res = new UserAccountI(value);
            await res.setupClient(env);
            return res;
        }
    }
    throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.ACCOUNT_DOES_NOT_EXIST, { name: name });
}
exports.getAccountByName = getAccountByName;
