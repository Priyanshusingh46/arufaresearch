"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBalanceChange = exports.getBalance = exports.supportChangeScrtBalance = void 0;
const chalk_1 = __importDefault(require("chalk"));
const context_1 = require("../../../internal/context");
const errors_1 = require("../../../internal/core/errors");
const errors_list_1 = require("../../../internal/core/errors-list");
const client_1 = require("../../client");
const contants_1 = require("../../contants");
function supportChangeScrtBalance(Assertion) {
    Assertion.addMethod('changeScrtBalance', function (// eslint-disable-line  @typescript-eslint/no-explicit-any
    account, balanceChange, includeFee, logResponse) {
        const subject = this._obj;
        if (account.account !== undefined) {
            account = account.account;
        }
        const accountAddr = account.address !== undefined
            ? account.address : account;
        const derivedPromise = Promise.all([
            getBalanceChange(subject, accountAddr, includeFee, logResponse)
        ]).then(([actualChange]) => {
            this.assert(actualChange === balanceChange, `Expected "${accountAddr}" to change balance by ${balanceChange} uscrt, ` +
                `but it has changed by ${actualChange} uscrt`, `Expected "${accountAddr}" to not change balance by ${balanceChange} uscrt,`, balanceChange, actualChange);
        });
        this.then = derivedPromise.then.bind(derivedPromise);
        this.catch = derivedPromise.catch.bind(derivedPromise);
        this.promise = derivedPromise;
        return this;
    });
}
exports.supportChangeScrtBalance = supportChangeScrtBalance;
function extractScrtBalance(balances) {
    console.log(balances);
    for (const coin of balances) {
        if (coin.denom === 'uscrt') {
            return Number(coin.amount);
        }
    }
    return 0;
}
async function getBalance(client, accountAddress) {
    if (client === undefined) {
        throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.CLIENT_NOT_LOADED);
    }
    const info = await client.query.bank.balance({
        address: accountAddress,
        denom: "uscrt"
    });
    if (info === undefined) {
        throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.BALANCE_UNDEFINED);
    }
    return [info.balance ?? { amount: "0", denom: "uscrt" }];
}
exports.getBalance = getBalance;
async function getBalanceChange(// eslint-disable-line sonarjs/cognitive-complexity
transaction, // eslint-disable-line  @typescript-eslint/no-explicit-any
accountAddr, includeFee, logResponse) {
    if (typeof transaction !== 'function') {
        throw new errors_1.PolarError(errors_list_1.ERRORS.GENERAL.NOT_A_FUNCTION, {
            param: transaction
        });
    }
    const client = await (0, client_1.getClient)(context_1.PolarContext.getPolarContext().getRuntimeEnv().network);
    const balanceBefore = extractScrtBalance(await getBalance(client, accountAddr));
    const txResponse = await transaction();
    if (logResponse === true) {
        console.log(`${chalk_1.default.green("Transaction response:")} ${txResponse}`);
    }
    const txnEvents = txResponse.logs[0].events;
    let msgEvent;
    for (const event of txnEvents) {
        if (event.type === 'message') {
            msgEvent = event;
            break;
        }
    }
    const msgEventKeys = {};
    for (const attr of msgEvent.attributes) {
        msgEventKeys[attr.key] = attr.value;
    }
    const balanceAfter = extractScrtBalance(await getBalance(client, accountAddr));
    const fees = Object.assign(Object.assign({}, contants_1.defaultFees), (context_1.PolarContext.getPolarContext().getRuntimeEnv().network.config.fees ?? {}));
    if (includeFee !== true &&
        accountAddr === msgEventKeys.signer) {
        if (accountAddr === msgEventKeys.signer) {
            return balanceAfter - balanceBefore;
        }
        else {
            let txnFees = 0;
            for (const [key, value] of Object.entries(fees)) {
                if (key === msgEventKeys.action) {
                    txnFees = Number(value);
                    break;
                }
            }
            return balanceAfter + txnFees - balanceBefore;
        }
    }
    else {
        return balanceBefore - balanceAfter;
    }
}
exports.getBalanceChange = getBalanceChange;
