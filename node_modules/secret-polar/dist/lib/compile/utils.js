"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAndParseTypes = exports.findExecuteMsg = exports.findQueryMsg = exports.readSchemas = void 0;
const fs_1 = require("fs");
const glob_1 = require("glob");
const polar_json_to_ts_1 = require("polar-json-to-ts");
const schemaParser_1 = require("./schemaParser");
const readSchemas = (schemaDir) => {
    const files = (0, glob_1.sync)(schemaDir + '/**/*.json');
    return files.map(file => JSON.parse((0, fs_1.readFileSync)(file, 'utf-8')));
};
exports.readSchemas = readSchemas;
const findQueryMsg = (schemas) => {
    return schemas.find((schema) => schema.title === 'QueryMsg');
};
exports.findQueryMsg = findQueryMsg;
const findExecuteMsg = (schemas) => {
    return schemas.find((schema) => schema.title === 'ExecuteMsg' ||
        schema.title === 'ExecuteMsg_for_Empty' || // if cleanse is used, this is never
        schema.title === 'ExecuteMsgForEmpty' ||
        schema.title === 'Cw20ExecuteMsg' ||
        schema.title === 'Snip20ExecuteMsg');
};
exports.findExecuteMsg = findExecuteMsg;
const findAndParseTypes = async (schemas // eslint-disable-line  @typescript-eslint/no-explicit-any
) => {
    const Types = schemas;
    const allTypes = [];
    for (const typ in Types) {
        if (Types[typ].definitions) {
            for (const key of Object.keys(Types[typ].definitions)) {
                // set title
                Types[typ].definitions[key].title = key;
            }
        }
        const result = await (0, polar_json_to_ts_1.compile)(Types[typ], Types[typ].title);
        allTypes.push(result);
    }
    return (0, schemaParser_1.parser)(allTypes);
};
exports.findAndParseTypes = findAndParseTypes;
