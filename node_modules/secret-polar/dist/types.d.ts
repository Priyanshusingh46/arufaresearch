/// <reference types="mocha" />
import { FeePool } from "secretjs/dist/protobuf_stuff/cosmos/distribution/v1beta1/distribution";
import * as types from "./internal/core/params/argument-types";
export interface Account {
    name: string;
    address: string;
    mnemonic: string;
}
export interface Coin {
    readonly denom: string;
    readonly amount: string;
}
export interface TxnStdFee {
    readonly amount: Coin[];
    readonly gas: string;
}
export interface StdFee {
    readonly upload: TxnStdFee;
    readonly init: TxnStdFee;
    readonly exec: TxnStdFee;
    readonly send: TxnStdFee;
    readonly amount: Coin[];
    readonly gas: string;
}
export interface UserAccount {
    account: Account;
    getBalance: () => Promise<Coin[]>;
}
export interface ContractInfo {
    codeId: number;
    contractCodeHash: string;
    deployTimestamp: string;
}
export interface Checkpoints {
    [network: string]: CheckpointInfo;
}
export interface CheckpointInfo {
    deployInfo?: DeployInfo;
    instantiateInfo?: InstantiateInfo;
    metadata?: Map<string, string>;
}
export interface InstantiateInfo {
    contractAddress: string;
    instantiateTimestamp: string;
}
export interface DeployInfo {
    codeId: number;
    contractCodeHash: string;
    deployTimestamp: string;
}
export declare type PolarNetworkAccountsUserConfig = Account[];
export interface PolarNetworkUserConfig {
    endpoint: string;
    accounts: PolarNetworkAccountsUserConfig;
    gasLimit?: string | number;
    chainId: string;
    fees?: Partial<FeePool>;
}
export interface NetworksUserConfig {
    [networkName: string]: NetworkUserConfig | undefined;
}
export declare type NetworkUserConfig = PolarNetworkUserConfig;
export declare type PolarNetworkConfig = PolarNetworkUserConfig;
export declare type NetworkConfig = PolarNetworkConfig;
export interface Networks {
    [networkName: string]: PolarNetworkConfig;
}
export declare type PolarNetworkAccountsConfig = PolarNetworkHDAccountsConfig | PolarNetworkAccountConfig[];
export interface PolarNetworkAccountConfig {
    privateKey: string;
    balance: string;
}
export interface PolarNetworkHDAccountsConfig {
    mnemonic: string;
    initialIndex: number;
    count: number;
    path: string;
    accountsBalance: string;
}
export interface PolarNetworkForkingConfig {
    enabled: boolean;
    url: string;
    blockNumber?: number;
}
export interface HttpNetworkConfig {
    chainId?: number;
    from?: string;
    gas: 'auto' | number;
    gasPrice: 'auto' | number;
    gasMultiplier: number;
    url: string;
    timeout: number;
    httpHeaders: {
        [name: string]: string;
    };
    accounts: HttpNetworkAccountsConfig;
}
export declare type HttpNetworkAccountsConfig = 'remote' | string[] | HttpNetworkHDAccountsConfig;
export interface HttpNetworkHDAccountsConfig {
    mnemonic: string;
    initialIndex: number;
    count: number;
    path: string;
}
export interface DockerConfig {
    sudo: boolean;
    runTestnet?: string;
}
export interface ProjectPathsUserConfig {
    root?: string;
    cache?: string;
    artifacts?: string;
    tests?: string;
}
export interface ProjectPathsConfig {
    root: string;
    configFile: string;
    cache: string;
    artifacts: string;
    tests: string;
    sources: string;
}
export declare type UserPaths = Omit<Partial<ProjectPathsConfig>, "configFile">;
export interface Config {
    networks?: Networks;
    paths?: UserPaths;
    mocha?: Mocha.MochaOptions;
}
export interface PolarUserConfig {
    defaultNetwork?: string;
    paths?: ProjectPathsUserConfig;
    networks?: NetworksUserConfig;
    mocha?: Mocha.MochaOptions;
    docker?: DockerConfig;
}
export interface PolarConfig {
    defaultNetwork: string;
    paths: ProjectPathsConfig;
    networks: Networks;
    mocha: Mocha.MochaOptions;
    docker: DockerConfig;
}
export declare type ConfigExtender = (config: ResolvedConfig, userConfig: Readonly<PolarUserConfig>) => void;
/**
 * A function that receives a RuntimeEnv and
 * modify its properties or add new ones.
 */
export declare type EnvironmentExtender = (env: PolarRuntimeEnvironment) => void;
/**
 * @type TaskArguments {object-like} - the input arguments for a task.
 *
 * TaskArguments type is set to 'any' because it's interface is dynamic.
 * It's impossible in TypeScript to statically specify a variadic
 * number of fields and at the same time define specific types for\
 * the argument values.
 *
 * For example, we could define:
 * type TaskArguments = Record<string, any>;
 *
 * ...but then, we couldn't narrow the actual argument value's type in compile time,
 * thus we have no other option than forcing it to be just 'any'.
 */
export declare type TaskArguments = any;
export declare type RunTaskFunction = (name: string, taskArguments?: TaskArguments) => PromiseAny;
export interface RunSuperFunction<ArgT extends TaskArguments> {
    (taskArguments?: ArgT): PromiseAny;
    isDefined: boolean;
}
export declare type ActionType<ArgsT extends TaskArguments> = (taskArgs: ArgsT, env: PolarRuntimeEnvironment, runSuper: RunSuperFunction<ArgsT>) => PromiseAny;
export interface Network {
    name: string;
    config: NetworkConfig;
}
interface RustVersion {
    version: string;
}
export interface ResolvedConfig extends PolarUserConfig {
    paths?: ProjectPathsConfig;
    rust?: RustVersion;
    networks: Networks;
}
/**
 * Polar arguments:
 * + network: the network to be used (default="default").
 * + showStackTraces: flag to show stack traces.
 * + version: flag to show polar's version.
 * + help: flag to show polar's help message.
 * + config: used to specify polar's config file.
 */
export interface RuntimeArgs {
    network: string;
    command?: string;
    useCheckpoints?: boolean;
    showStackTraces: boolean;
    version: boolean;
    help: boolean;
    config?: string;
    verbose: boolean;
}
export interface ConfigurableTaskDefinition {
    setDescription: (description: string) => this;
    setAction: (action: ActionType<TaskArguments>) => this;
    addParam: <T>(name: string, description?: string, defaultValue?: T, type?: types.ArgumentType<T>, isOptional?: boolean) => this;
    addOptionalParam: <T>(name: string, description?: string, defaultValue?: T, type?: types.ArgumentType<T>) => this;
    addPositionalParam: <T>(name: string, description?: string, defaultValue?: T, type?: types.ArgumentType<T>, isOptional?: boolean) => this;
    addOptionalPositionalParam: <T>(name: string, description?: string, defaultValue?: T, type?: types.ArgumentType<T>) => this;
    addVariadicPositionalParam: <T>(name: string, description?: string, defaultValue?: T[], type?: types.ArgumentType<T>, isOptional?: boolean) => this;
    addOptionalVariadicPositionalParam: <T>(name: string, description?: string, defaultValue?: T[], type?: types.ArgumentType<T>) => this;
    addFlag: (name: string, description?: string) => this;
}
export interface ParamDefinition<T> {
    name: string;
    shortName?: string;
    defaultValue?: T;
    type: types.ArgumentType<T>;
    description?: string;
    isOptional: boolean;
    isFlag: boolean;
    isVariadic: boolean;
}
export declare type ParamDefinitionAny = ParamDefinition<any>;
export interface OptionalParamDefinition<T> extends ParamDefinition<T> {
    defaultValue: T;
    isOptional: true;
}
export interface ParamDefinitionsMap {
    [paramName: string]: ParamDefinitionAny;
}
export declare type ParamDefinitions = {
    [param in keyof Required<RuntimeArgs>]: OptionalParamDefinition<RuntimeArgs[param]>;
};
export interface ShortParamSubstitutions {
    [name: string]: string;
}
export interface TaskDefinition extends ConfigurableTaskDefinition {
    readonly name: string;
    readonly description?: string;
    readonly action: ActionType<TaskArguments>;
    readonly isInternal: boolean;
    readonly paramDefinitions: ParamDefinitionsMap;
    readonly positionalParamDefinitions: ParamDefinitionAny[];
}
export interface TasksMap {
    [name: string]: TaskDefinition;
}
export interface PolarRuntimeEnvironment {
    readonly config: ResolvedConfig;
    readonly runtimeArgs: RuntimeArgs;
    readonly tasks: TasksMap;
    readonly run: RunTaskFunction;
    readonly network: Network;
}
export declare type PromiseAny = Promise<any>;
export interface StrMap {
    [key: string]: string;
}
export declare type AnyJson = string | number | boolean | null | undefined | AnyJson[] | {
    [index: string]: AnyJson;
};
export declare type AnyFunction = (...args: any[]) => any;
export declare type AnyNumber = bigint | Uint8Array | number | string;
export declare type AnyString = string | string;
export declare type AnyU8a = Uint8Array | number[] | string;
export declare type ContractFunction<T = any> = (// eslint-disable-line  @typescript-eslint/no-explicit-any
...args: any[]) => Promise<T>;
export {};
